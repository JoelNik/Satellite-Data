<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Planet Coverage </title>
  <style>

  </style>
</head>

<body>
  <div id="map"></div>
  <div id="tooltip"></div>
  
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <script src="/satellite.min.js"></script>
 


  <script>
  
  // Sets up the SVG for the map
  var height = 600;
  var width = 900;
  var coverage = void 0; 

  var svg = d3.select("#map")
      .append("svg")
      .attr("width", width)
      .attr("height", height);
  
  var map = svg.append('g')
  			   .attr('class', 'images');

  // Sets up projection 
  projection = d3.geo.mercator();
  var path = d3.geo.path().projection(projection);

  // Loads the scene boundaries  
  d3.json('results_new.json', function(data) { 
    
    scenes = data;

    // Adds the CA state boundary 
    d3.json("ca.geojson", function(error, data) {
      if (error) throw error;
      ca = data;
      console.log(ca);      

      // Scales and translates projection
      //b, s, t;
      projection.scale(1).translate([0, 0]);
      var b, s, t;
      var b = path.bounds(ca);
      var s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height);
      var t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];
      projection.scale(s).translate(t);

      svg.append("g")
          .attr("class", "boundaries")
        .selectAll("path")
        .data(ca)
        .enter().append("path")
          .attr("d", path);    

     
      // Draws out the distric boundaries
      images = map.selectAll('path').data(scenes.features);
      console.log(scenes);

      images.enter()
         .append('path')
         .attr('d', path)
         .attr('id', function(d, i) {return "s" + i;} )
         .attr('fill-opacity', 0)
         .sort(function(a,b) {if (a.properties.acquired > b.properties.acquired) { return 1;} else { return -1}} )
         .transition()
         .delay(function(d,i) {return 500;} ) 
         .duration(1000)
         .attr('fill-opacity', 1)
         .attr('fill', 'red');

      // Remove elements (not really necessary)
      images.exit().remove();


      d3.text("landsat8.txt", function(error2, data) {
        if (error2) throw error2;

        // Preps the Landsat TLE data
        var stations = [];
        var lines = data.split("\n");
        lines.forEach(function(line) {
          if (line.length == 0) return;

          if (line[0] == "1") {
            var obj = stations[stations.length-1];
            obj.tle1 = line;
            return; 
          }

          if (line[0] == "2") {
            var obj = stations[stations.length-1];
            obj.tle2 = line;
            return; 
          }

          stations.push({
            name: line.trim()
          });

          console.log(lines);

        });

        // Gives us a default start date of first satellite pass 
        var time_1 = new Date(d3.min(scenes.features.map(function(d) { return d.properties.acquired })));
        
        // Create element that we'll modify to show moving satellite
        landsat = svg.append('g')
                        .attr('class', 'satellite')
                     .append('circle')
                        .attr('id', 'landsat')
                        .attr('r', 4)
                        .attr('fill', 'black');


        d3.timer(function(elapsed) {
          var interval = 300;
          time_1 = new Date(time_1.getTime() + interval);
          console.log(time_1);
  
          stations.forEach(function(d) {
            plotsat(d, time_1);
            });
        });


      });

    });
  });
  
 // Function to update the satellite 
  function plotsat(station, time) {
    var satrec = satellite.twoline2satrec(station.tle1, station.tle2);

    // Find position from TLE and input time
    var pos_vel = satellite.propagate(
        satrec,
        time.getUTCFullYear(),
        time.getUTCMonth() + 1, // Requires months in range 1-12.
        time.getUTCDate(),
        time.getUTCHours(),
        time.getUTCMinutes(),
        time.getUTCSeconds()
    );

    // Find the sidereal time (i.e. the rotational position of the earth)
    var gmst = satellite.gstimeFromDate(
        time.getUTCFullYear(),
        time.getUTCMonth() + 1, // Requires months in range 1-12.
        time.getUTCDate(),
        time.getUTCHours(),
        time.getUTCMinutes(),
        time.getUTCSeconds()
    );

    // Pull out position and covert into ground coordinates in long/lat format
    var pos_eci = pos_vel.position,
        vel_eci = pos_vel.velocity;
    var pos = satellite.eciToGeodetic(pos_eci, gmst)
    var xy = projection([pos.longitude*180/Math.PI, pos.latitude*180/Math.PI]);
    landsat.attr('cx',  xy[0])
    landsat.attr('cy',  xy[1])

    if ((xy[0] < 0) || (xy[0] > width) || (xy[1] < 0) || (xy[1] > height)) {
      time_1 = new Date(scenes.features[Math.floor(Math.random() * (scenes.features.length - 1))].properties.acquired );
      console.log("made it!");
    }
  };

  </script>
</body>
</html>


